<!DOCTYPE html>
<html lang="en">

<head>
  <title>Project</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  <!-- Compiled and minified CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">

  <!-- Compiled and minified JavaScript -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>


<body>


  <div class="fixed-action-btn">
    <a class="btn-floating btn-large red" id="fab_main">
      <i class="large material-icons" id="fab_main_icon">play_arrow</i>
    </a>
    <ul>
      <li><a class="btn-floating red" id="fab_secondary"><i class="material-icons"
            id="fab_secondary_icon">gamepad</i></a>
      </li>
    </ul>
  </div>

  <div id="help_modal" class="modal modal-fixed-footer">
    <div class="modal-content">
      <h4>Help!</h4>
      <p>Click on <b>"Add a cannon"</b> to add a cannon to the scene</p>
      <p>You can modify the <b>gravity</b> in the scene using the sclider in the menu</p>
      <p>Once you have a cannon in the scene you can <b>select it with left click</b></p>
      <p>If you want to <b>remove a cannon right click on it</b></p>
      <p>After you select a <b>cannon a menu</b> of the cannon will appear</p>
      <ul>
        <li>- Air resistance (kg/s): Coefficient which represents how much the air slows down the ball due it's
          velocity.</li>
        <li>- Mass of the ball (kg): Without air resistance, the mass is not needed for calculations, otherwise it's a
          key element into the computation. The more massive, the less is affected the ball by the air resistance.</li>
        <li>- Elastic Coefficient (Not units): This coefficient represents the ratio of the speed of the ball (in y
          axis) after collisioning the floor. Set 1 for not lose energy in the collision!.</li>
        <li>- Cannon angle (degrees): Angle of the cannon's barrel respect the floor's plane.</li>
        <li>- Initial Speed (m/s): Initial speed of the ball.</li>
        <li>- Gravity aceleration (m/s^2): Set your own gravity field! Earth's gravity acceleration constant is
          9.81m/s^2.</li>
      </ul>
      <p>While you have the <b>cannon selected you can</b>: </p>
      <ul>
        <li>- Move and rotate it on screen using the arrows that appeared</li>
        <li>- If you press the <b>R key</b>, you can change to <b>rotation</b> mode</li>
        <li>- If you press the <b>T key</b>, you can change to <b>translation</b> mode</li>
        <li>- If you press the <b>C key</b>, it will create an exact <b>replica</b> of the cannon in the same place (you
          need to move
          the current cannon to see the copy)</li>
      </ul>
      <p>In the bottom right corner you can see <b>play button</b>, if pressed it will start the <b>simulation</b></p>
      <p>If you hover the mouse over the play button a <b>sub-button</b> will appear, it allows to <b>change the
          mode</b></p>
      <ul>
        <li>- <b>Simulation mode(default)</b>: It allows you to test the different properties of the cannon and the
          scene and compare it with other cannons</li>
        <li>- <b>Game mode</b>: It automatically sets a cannon and gives you information of the properties of it and the
          scene, your objective is to set the other properties to hit the barrel that appeared randomly in the scene
        </li>
      </ul>
    </div>
    <div class="modal-footer">
      <a href="#!" class="modal-close waves-effect waves-green btn-flat">Accept</a>
    </div>
  </div>

  <div id="references_modal" class="modal modal-fixed-footer">
    <div class="modal-content">
      <h4>References</h4>
      <p><b>Background texture</b>: <a href="http://www.humus.name/index.php?page=Textures">Yokohama 3 by Humus</a></p>
      <p><b>Cannon texture</b>: <a
          href="https://lostandtaken.com/downloads/scratched-scraped-metal-texture-12/">Scratched And Scraped Metal
          Texture by Lost & Taken</a></p>
      <p><b>Cannon wheel texture</b>: <a href="https://www.rgbstock.de/photo/n8BF7A2/Rock+texture">Rock texture by
          Christine Landis</a></p>
      <p><b>Barrel model</b>: <a href="https://www.turbosquid.com/es/3d-models/cannon-low-poly-3d-model-1713475">by
          Derdaryen</a></p>
      <!-- TODO: referencias plox -->
    </div>
    <div class="modal-footer">
      <a href="#!" class="modal-close waves-effect waves-green btn-flat">Close</a>
    </div>
  </div>

  <div id="game_modal" class="modal modal-fixed-footer">
    <div class="modal-content">
      <h4>Game instructions</h4>
      <p>Welcome to the game mode!</p>
      <p>The properties of the current game are: </p>
      <ul>
        <!-- TODO units please despues del span dentro del li plox -->
        <li>-<b>Gravity:</b> <span id="gravity_info"></span></li>
        <li>-<b>Air resistance:</b> <span id="air_info"></span></li>
        <li>-<b>Mass of ball:</b> <span id="mass_info"></span></li>
      </ul>
      <p>Hit the barrel in the least amount of attempts, have fun!</p>
    </div>
    <div class="modal-footer">
      <a href="#!" class="modal-close waves-effect waves-green btn-flat">Accept</a>
    </div>
  </div>


  <script type="module">
    "using strict";
    import * as THREE from "https://unpkg.com/three@0.127.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.127.0/examples/jsm/controls/OrbitControls.js";
    import { TransformControls } from "https://unpkg.com/three@0.127.0/examples/jsm/controls/TransformControls.js";
    import Stats from "https://unpkg.com/three@0.127.0/examples/jsm/libs/stats.module.js";
    import dat from "https://unpkg.com/three@0.127.0/examples/jsm/libs/dat.gui.module.js";
    import { OBJLoader } from "https://unpkg.com/three@0.127.0/examples/jsm/loaders/OBJLoader.js";
    import { MTLLoader } from "https://unpkg.com/three@0.127.0/examples/jsm/loaders/MTLLoader.js";

    class Composite extends THREE.Group {
      constructor() {
        super();
        this.matrixModel = new THREE.Matrix4();
      }

      addWiframeHelper(color = new THREE.Color(0, 0, 0)) {
        this.wireframeHelper = new THREE.LineSegments(new THREE.WireframeGeometry(this.geometry));
        this.wireframeHelper.material.color = color;
        this.add(this.wireframeHelper);
      }

      addLocalAxes(visible = false) {
        this.geometry.computeBoundingSphere();
        this.axes = new THREE.AxesHelper(this.geometry.boundingSphere.radius * 1.5);
        this.axes.visible = visible;
        this.add(this.axes);
      }

      getCentroid() {
        this.geometry.computeBoundingSphere();
        return this.geometry.boundingSphere.center;
      }

      getScale(sx, sy, sz) {
        let S = new THREE.Matrix4();
        S.makeScale(sx, sy, sz);
        return S;
      }

      getRotationX(theta) {
        let R = new THREE.Matrix4();
        R.makeRotationX(theta);
        return R;
      }

      getRotationY(theta) {
        let R = new THREE.Matrix4();
        R.makeRotationY(theta);
        return R;
      }

      getRotationZ(theta) {
        let R = new THREE.Matrix4();
        R.makeRotationZ(theta);
        return R;
      }

      getRotationXQ(theta, xq, yq, zq) {
        // M = T2(xq,yq,zq) Rx T1(-xq,-yq,-zq)
        let T2 = this.getTranslation(xq, yq, zq);
        let Rx = this.getRotationX(theta);
        let T1 = this.getTranslation(-xq, -yq, -zq);
        let M = new THREE.Matrix4();
        M.multiplyMatrices(T2, Rx);
        M.multiplyMatrices(M, T1);
        return M;
      }

      getRotationYQ(theta, xq, yq, zq) {
        // M = T2(xq,yq,zq) Ry T1(-xq,-yq,-zq)
        let T2 = this.getTranslation(xq, yq, zq);
        let Ry = this.getRotationY(theta);
        let T1 = this.getTranslation(-xq, -yq, -zq);
        let M = new THREE.Matrix4();
        M.multiplyMatrices(T2, Ry);
        M.multiplyMatrices(M, T1);
        return M;
      }

      getRotationZQ(theta, xq, yq, zq) {
        // M = T2(xq,yq,zq) Rz T1(-xq,-yq,-zq)
        let T2 = this.getTranslation(xq, yq, zq);
        let Rz = this.getRotationZ(theta);
        let T1 = this.getTranslation(-xq, -yq, -zq);
        let M = new THREE.Matrix4();
        M.multiplyMatrices(T2, Rz);
        M.multiplyMatrices(M, T1);
        return M;
      }

      getTranslation(tx, ty, tz) {
        let T = new THREE.Matrix4();
        T.makeTranslation(tx, ty, tz);
        return T;
      }

      addScale(sx, sy, sz) {
        let S = new THREE.Matrix4();
        S.makeScale(sx, sy, sz);
        this.matrixModel.multiply(S);
        this.setMatrix();
      }

      addRotationX(theta) {
        let R = new THREE.Matrix4();
        R.makeRotationX(theta);
        this.matrixModel.multiply(R);
        this.setMatrix();
      }

      addRotationY(theta) {
        let R = new THREE.Matrix4();
        R.makeRotationY(theta);
        this.matrixModel.multiply(R);
        this.setMatrix();
      }

      addRotationZ(theta) {
        let R = new THREE.Matrix4();
        R.makeRotationZ(theta);
        this.matrixModel.multiply(R);
        this.setMatrix();
      }

      addRotationXQ(theta, xq, yq, zq) {
        this.addTranslation(xq, yq, zq);
        this.addRotationX(theta);
        this.addTranslation(-xq, -yq, -zq);
        this.setMatrix();
      }

      addTranslation(tx, ty, tz) {
        let T = new THREE.Matrix4();
        T.makeTranslation(tx, ty, tz);
        this.matrixModel.multiply(T);
        this.setMatrix();
      }

      animateRotXQ(theta, xq, yq, zq) {
        let RXQ = this.getRotationXQ(theta, xq, yq, zq);
        let M = new THREE.Matrix4();
        M.multiplyMatrices(RXQ, this.matrixModel);
        this.setMatrix(M);
      }

      setMatrix(matrix = this.matrixModel) {
        this.matrixAutoUpdate = false;
        this.matrix.copy(matrix);

        this.position.setFromMatrixPosition(this.matrix);
        this.setRotationFromMatrix(this.matrix);

      }

      setMatrixIdentity() {
        this.matrixAutoUpdate = false;
        this.matrix.copy(new THREE.Matrix4());

        this.position.setFromMatrixPosition(this.matrix);
        this.setRotationFromMatrix(this.matrix);
      }

      // Set matrix with matrixModel
      resetMatrix() {
        this.matrixAutoUpdate = false;
        this.matrix.copy(this.matrixModel);
        this.position.setFromMatrixPosition(this.matrix);
        this.setRotationFromMatrix(this.matrix);
      }

    }

    class CannonBarrelFront extends THREE.Mesh {
      constructor(father) {
        super();
        this.father = father;
        this.geometry = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 64,
          1, true);
        const loader = new THREE.TextureLoader();
        this.material = new THREE.MeshPhongMaterial({
          map: loader.load('./textures/metal.jpg'), side: THREE.DoubleSide
        });
        //this.material = new THREE.MeshBasicMaterial({color: "#485555", side: THREE.DoubleSide});
        //this.addWiframeHelper(new THREE.Color(0, 0, 0));

      }
    }

    class CannonBarrelBack extends THREE.Mesh {
      constructor(father) {
        super();
        this.father = father;
        this.geometry = new THREE.SphereGeometry(0.43, 32, 32);
        const loader = new THREE.TextureLoader();
        this.material = new THREE.MeshPhongMaterial({
          map: loader.load('./textures/metal.jpg'), side: THREE.DoubleSide
        });
        //this.material = new THREE.MeshBasicMaterial({color: "#485555", side: THREE.DoubleSide});
        //this.addWiframeHelper(new THREE.Color(0, 0, 0));

      }
    }

    class CannonBarrelRing extends THREE.Mesh {
      constructor(father) {
        super();
        this.father = father;
        this.geometry = new THREE.TorusGeometry(0.4, 0.08, 30, 100);
        const loader = new THREE.TextureLoader();
        this.material = new THREE.MeshPhongMaterial({
          map: loader.load('./textures/metalDetails.jpg'), side: THREE.DoubleSide
        });
        //this.material = new THREE.MeshBasicMaterial({color: "#646868", side: THREE.DoubleSide});
        //this.addWiframeHelper(new THREE.Color(0, 0, 0));
        this.rotation.x = -Math.PI / 2;

      }
    }

    class CannonBarrel extends Composite {
      constructor(father) {
        super();
        this.children = [];
        this.father = father;
        this.barrelFront = new CannonBarrelFront(father);
        this.barrelFrontInner = new CannonBarrelFront(father);
        this.barrelFrontInner.scale.set(.8, 1, .8);
        this.barrelBack = new CannonBarrelBack(father);
        this.barrelBack.position.set(0, 0.75, 0);
        this.barrelBack2 = new CannonBarrelBack(father);
        this.barrelBack2.position.set(0, 1.15, 0);
        this.barrelBack2.scale.set(.3, .3, .3);
        this.barrelRing = new CannonBarrelRing(father);
        this.barrelRing.position.set(0, -0.75, 0);
        this.barrelRing1 = new CannonBarrelRing(father);
        this.barrelRing1.position.set(0, 0.06, 0);
        this.barrelRing1.scale.set(.9, .9, .5);
        this.barrelRing2 = new CannonBarrelRing(father);
        this.barrelRing2.position.set(0, -0.06, 0);
        this.barrelRing2.scale.set(.9, .9, .5);
        this.barrelRing3 = new CannonBarrelRing(father);
        this.barrelRing3.position.set(0, .60, 0);
        this.barrelRing3.scale.set(.9, .9, .5);

        this.add(this.barrelFront);
        this.add(this.barrelFrontInner);
        this.add(this.barrelBack);
        this.add(this.barrelBack2);
        this.add(this.barrelRing);
        this.add(this.barrelRing1);
        this.add(this.barrelRing2);
        this.add(this.barrelRing3);

        this.children.push(this.barrelFront);
        this.children.push(this.barrelFrontInner);
        this.children.push(this.barrelBack);
        this.children.push(this.barrelBack2);
        this.children.push(this.barrelRing);
        this.children.push(this.barrelRing1);
        this.children.push(this.barrelRing2);
        this.children.push(this.barrelRing3);
        this.position.set(0, 0.35, .4);
      }
    }

    class CannonBaseBox extends THREE.Mesh {
      constructor(father) {
        super();
        this.father = father;
        this.geometry = new THREE.BoxGeometry(1, 1, 1);
        const loader = new THREE.TextureLoader();
        this.material = new THREE.MeshPhongMaterial({
          map: loader.load('./textures/woodPlank.jpg'),
        });
        //this.material = new THREE.MeshBasicMaterial({color: "#664230", side: THREE.DoubleSide});
        //this.addWiframeHelper(new THREE.Color(0, 0, 0));
        this.rotation.x = -Math.PI / 2;

      }

    }

    class CannonBaseWheel extends THREE.Mesh {
      constructor(father) {
        super();
        this.father = father;
        this.geometry = new THREE.CylinderGeometry(0.5, 0.5, .1, 64,
          1, false);
        const loader = new THREE.TextureLoader();
        this.material = new THREE.MeshPhongMaterial({
          map: loader.load('./textures/rock.jpg'), side: THREE.DoubleSide
        });
        //this.material = new THREE.MeshBasicMaterial({color: "#485555", side: THREE.DoubleSide});
        //this.addWiframeHelper(new THREE.Color(0, 0, 0));
        this.rotation.z = -Math.PI / 2;

      }
    }

    class CannonBaseBolt extends THREE.Mesh {
      constructor(father) {
        super();
        this.father = father;
        this.geometry = new THREE.CylinderGeometry(0.5, 0.5, .1, 64,
          1, false);
        const loader = new THREE.TextureLoader();
        this.material = new THREE.MeshPhongMaterial({
          map: loader.load('./textures/metalDetails.jpg'), side: THREE.DoubleSide
        });
        //this.material = new THREE.MeshBasicMaterial({color: "#363939", side: THREE.DoubleSide});
        //this.addWiframeHelper(new THREE.Color(0, 0, 0));
        this.rotation.z = -Math.PI / 2;

      }
    }

    class CannonBase extends Composite {
      constructor(father) {
        super();
        this.children = [];
        this.father = father;
        this.frontBox = new CannonBaseBox(father);
        this.frontBox.scale.set(1.6, .5, .7);
        this.frontBox.position.set(0, -.5, .7);
        this.add(this.frontBox);
        this.children.push(this.frontBox);

        this.floorBox = new CannonBaseBox(father);
        this.floorBox.scale.set(1.6, 2, .19);
        this.floorBox.position.set(0, -.95, -.05);
        this.add(this.floorBox);
        this.children.push(this.floorBox);

        this.rightUpBox = new CannonBaseBox(father);
        this.rightUpBox.scale.set(.09, 1, .23);
        this.rightUpBox.position.set(.75, -.26, 0.3);
        this.add(this.rightUpBox);
        this.children.push(this.rightUpBox);
        this.rightMiddleBox = new CannonBaseBox(father);
        this.rightMiddleBox.scale.set(.09, 1.5, .23);
        this.rightMiddleBox.position.set(.75, -.52, 0.15);
        this.add(this.rightMiddleBox);
        this.children.push(this.rightMiddleBox);
        this.rightDownBox = new CannonBaseBox(father);
        this.rightDownBox.scale.set(.09, 1.7, .23);
        this.rightDownBox.position.set(.75, -.78, -.08);
        this.add(this.rightDownBox);
        this.children.push(this.rightDownBox);

        this.leftUpBox = new CannonBaseBox(father);
        this.leftUpBox.scale.set(.09, 1, .23);
        this.leftUpBox.position.set(-.75, -.26, 0.3);
        this.add(this.leftUpBox);
        this.children.push(this.leftUpBox);
        this.leftMiddleBox = new CannonBaseBox(father);
        this.leftMiddleBox.scale.set(.09, 1.5, .23);
        this.leftMiddleBox.position.set(-.75, -.52, 0.15);
        this.add(this.leftMiddleBox);
        this.children.push(this.leftMiddleBox);
        this.leftDownBox = new CannonBaseBox(father);
        this.leftDownBox.scale.set(.09, 1.7, .23);
        this.leftDownBox.position.set(-.75, -.78, -.08);
        this.add(this.leftDownBox);
        this.children.push(this.leftDownBox);

        this.frontRightWheel = new CannonBaseWheel(father);
        this.frontRightWheel.position.set(.9, -.79, .7);
        this.add(this.frontRightWheel);
        this.children.push(this.frontRightWheel);
        this.frontRightBolt = new CannonBaseBolt(father);
        this.frontRightBolt.scale.set(.1, 2, .1);
        this.frontRightBolt.position.set(.9, -.79, .7);
        this.add(this.frontRightBolt);
        this.children.push(this.frontRightBolt);

        this.frontLeftWheel = new CannonBaseWheel(father);
        this.frontLeftWheel.position.set(-.9, -.79, .7);
        this.add(this.frontLeftWheel);
        this.children.push(this.frontLeftWheel);
        this.frontLeftBolt = new CannonBaseBolt(father);
        this.frontLeftBolt.scale.set(.1, 2, .1);
        this.frontLeftBolt.position.set(-.9, -.79, .7);
        this.add(this.frontLeftBolt);
        this.children.push(this.frontLeftBolt);

        this.backRightWheel = new CannonBaseWheel(father);
        this.backRightWheel.scale.set(.7, 1, .7);
        this.backRightWheel.position.set(.9, -.95, -.7);
        this.add(this.backRightWheel);
        this.children.push(this.backRightWheel);
        this.backRightBolt = new CannonBaseBolt(father);
        this.backRightBolt.scale.set(.1, 2, .1);
        this.backRightBolt.position.set(.9, -.95, -.7);
        this.add(this.backRightBolt);
        this.children.push(this.backRightBolt);

        this.backLeftWheel = new CannonBaseWheel(father);
        this.backLeftWheel.scale.set(.7, 1, .7);
        this.backLeftWheel.position.set(-.9, -.95, -.7);
        this.add(this.backLeftWheel);
        this.children.push(this.backLeftWheel);
        this.backLeftBolt = new CannonBaseBolt(father);
        this.backLeftBolt.scale.set(.1, 2, .1);
        this.backLeftBolt.position.set(-.9, -.95, -.7);
        this.add(this.backLeftBolt);
        this.children.push(this.backLeftBolt);



      }
    }

    class Cannon extends THREE.Group {

      properties = { rotX: 0, ball_speed: 1, ball_mass: 1.0, impact_elastic_coefficient: 1.0, air_resistance_coefficient_b: 1.0 }

      constructor() {
        super();

        this.barrel = new CannonBarrel(this);
        this.barrel.rotation.x = -Math.PI / 2;
        this.base = new CannonBase(this);
        this.ball = null;
        this.add(this.base);
        this.add(this.barrel);
        this.position.set(0, 1.3, 0);
      }
    }

    const bounce_states = {
      START: 0,
      HAS_NOT_BOUNCED: 1,
      HAS_BOUNCED: 2,
    }

    class CannonBall extends THREE.Mesh {
      properties = {
        bounce_status: bounce_states.START,
        last_time_bounce: 0.0,
        mass: 0.1,
        radius: 1.0,
        initial_position: new THREE.Vector3(0, 0, 0),
        displacement: new THREE.Vector3(0, 0, 0),
        initial_velocity: new THREE.Vector3(0, 0, 0),
        velocity: new THREE.Vector3(0, 0, 0),
        acceleration: new THREE.Vector3(0, state.gravity, 0),
      }

      constructor(mass = 1.0, radius = 1.0) {
        super();
        this.properties.mass = mass;
        this.properties.radius = radius;
        this.geometry = new THREE.SphereGeometry(radius, 32, 32);
        const loader = new THREE.TextureLoader();
        this.material = new THREE.MeshPhongMaterial({
          color: 0xff00ff, side: THREE.DoubleSide,
          //map: loader.load('./textures/metalDetails.jpg'),side: THREE.DoubleSide
        });
      }

      setInitialPosition(pos) {
        this.properties.initial_position.x = pos.x;
        this.position.x = pos.x;
        this.properties.initial_position.y = pos.y;
        this.position.y = pos.y;
        this.properties.initial_position.z = pos.z;
        this.position.z = pos.z;
      }

      setInitialVelocity(vel) {
        this.properties.initial_velocity.x = vel.x;
        this.properties.velocity.x = vel.x;
        this.properties.initial_velocity.y = vel.y;
        this.properties.velocity.y = vel.y;
        this.properties.initial_velocity.z = vel.z;
        this.properties.velocity.z = vel.z;
      }
    }

    class Target {
      static OBJFile = 'models/barrel.obj';
      static MTLFile = 'textures/barrel.mtl';

      static baseTarget = null;

      static objPromise = (materials) => new Promise((resolve, reject) => {
        new OBJLoader().setMaterials(materials).load(Target.OBJFile, (m) => {
          resolve(m)
        }, () => { },
          (e) => { reject(e) });
      })

      static mtlPromise = () => new Promise((resolve, reject) => {
        new MTLLoader().load(Target.MTLFile, (m) => {
          m.preload();
          resolve(m)
        }, () => { },
          (e) => { reject(e) });
      })

      async build(x, y, z) {
        if (Target.baseTarget) {
          const target = Target.baseTarget.clone();
          target.position.set(x, y, z)
          return target;
        }
        try {
          const materials = await Target.mtlPromise();
          const target = (await Target.objPromise(materials)).children[0];
          target.position.set(x, y, z)
          target.scale.set(4, 4, 4)
          Target.baseTarget = target;
          return target;
        }
        catch (err) { console.log(err) }
      }
    }

    // THREEjs variables
    let scene, renderer, stats, cameraControls, transfControl, gui, modelMenu;
    let cameras = []; // perspective, top, fron, side
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const state = {
      references: () => {
        console.log(document.getElementById("references_modal"))
        const instance = M.Modal.getInstance(document.getElementById("references_modal"));
        instance.open();
      },
      help: () => {
        console.log(document.getElementById("help_modal"))
        const instance = M.Modal.getInstance(document.getElementById("help_modal"));
        instance.open();
      },
      addCannon: () => {
        add(new Cannon())
      },
      objects: [],
      cannons: [],
      lines: [],
      editMode: true,
      gameMode: false,
      selectedObject: null,
      totalTries: 0,
      transforming: false,
      isAnimationStarted: false,
      target: null,
      gravity: 9.81,
    };

    // Camera configuration
    let fovy = 60.0;    // Field ov view
    let aspectRatio = window.innerWidth / window.innerHeight;
    let nearPlane = 0.1;
    let farPlane = 10000.0;

    const map_size = 128;

    const MAX_POINTS = 1000000;
    let curr_point = 0;

    const line_colors = [0xff0000, 0x00ffff, 0xff00ff, 0x00ff00, 0xffff00, 0x0000ff, 0xdddddd];

    const domFabMain = document.getElementById("fab_main")
    const domFabSecondary = document.getElementById("fab_secondary")
    const domFabMainIcon = document.getElementById("fab_main_icon")
    const domFabSecondaryIcon = document.getElementById("fab_secondary_icon")

    //Physics variables
    let start_time;

    domFabMain.onclick = () => {
      state.editMode = !state.editMode
      state.selectedObject = null;
      if (!state.editMode) {
        domFabMainIcon.innerHTML = "stop"
        domFabSecondary.style.display = "none"
        transfControl.detach();
        removeModelMenu();
        gui.close();
        document.getElementById("addCannonbtn").style.display = "none"
        document.getElementById("gravityField").style.display = "none"
        curr_point = 0;
        // Set cannonBalls

        state.cannons.forEach((c, i) => {
          // initializing lines per cannon
          const material = new THREE.LineBasicMaterial({ color: line_colors[i % line_colors.length], linewidth: 20 });
          const geometry = new THREE.BufferGeometry();
          const positions = new Float32Array(MAX_POINTS * 3);
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setDrawRange(0, 0);
          const line = new THREE.Line(geometry, material);
          state.lines.push(line)
          scene.add(line)

          c.ball = new CannonBall(c.properties.ball_mass, 0.5);
          c.ball.setInitialPosition(new THREE.Vector3(
            c.barrel.position.x + c.position.x,
            c.barrel.position.y + c.position.y,
            c.barrel.position.z + c.position.z
          ));

          let theta = -(c.barrel.rotation.x + Math.PI / 2);
          let phi = c.rotation.x === 0 ? c.rotation.y : Math.PI - c.rotation.y;

          c.ball.setInitialVelocity(new THREE.Vector3(
            c.properties.ball_speed * Math.cos(theta) * Math.sin(phi),
            c.properties.ball_speed * Math.sin(theta),
            c.properties.ball_speed * Math.cos(theta) * Math.cos(phi)
          ));
          scene.add(c.ball);

        });

        if (state.gameMode) {
          state.totalTries += 1;
        }
      }
      else {
        // TODO if something needs to be stopped/removed/cleaned

        state.cannons.forEach((c) => {
          scene.remove(c.ball);
          c.ball = null;
        });

        state.lines.forEach((l) => {
          scene.remove(l)
        })
        state.lines = []

        gui.open();
        domFabSecondary.style.display = "inline-block"
        document.getElementById("addCannonbtn").style.display = "block"
        document.getElementById("gravityField").style.display = "block"
        domFabMainIcon.innerHTML = "play_arrow"
      }
    }

    const cleanUp = () => {
      state.cannons.forEach((c) => {
        scene.remove(c);
        scene.remove(c.ball);
        state.selectedObject = null;
        c.ball = null;
      });
      state.cannons = []
      state.objects = []
      if (state.target) {
        scene.remove(state.target)
        state.target = null;
      }
      state.gravity = 9.81;
    }

    const setGameMode = async () => {
      const gravity = Math.ceil(Math.random() * 25)
      const resistance = Number(Math.random().toFixed(2));
      const mass = Math.ceil(Math.random() * 9)
      let cannon = new Cannon();
      cannon.properties.air_resistance_coefficient_b = resistance;
      cannon.properties.ball_mass = mass;
      state.gravity = gravity;
      add(cannon);

      transfControl.showX = false
      transfControl.showY = true
      transfControl.showZ = false
      transfControl.setMode("rotate")

      document.getElementById("gravityField").style.display = "none"
      document.getElementById("addCannonbtn").style.display = "none"

      document.getElementById("gravity_info").innerText = gravity
      document.getElementById("air_info").innerText = resistance
      document.getElementById("mass_info").innerText = mass

      const instance = M.Modal.getInstance(document.getElementById("game_modal"));
      instance.open();

      const x = Math.ceil(Math.random() * map_size / 2 - 8) * (Math.round(Math.random()) ? 1 : -1)
      const y = Math.floor(Math.random() * map_size / 2 - 20) + 10;
      const z = Math.ceil(Math.random() * map_size / 2 - 8) * (Math.round(Math.random()) ? 1 : -1)
      const target = await new Target().build(x, y, z);
      // BOUNDING BOX
      // const geometry = new THREE.BoxGeometry(3, 5, 3);
      // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
      // const cube = new THREE.Mesh(geometry, material);
      // cube.position.set(x, y + 2.45, z)
      // scene.add(cube);
      scene.add(target)
      state.target = target;
      state.totalTries = 0
    }

    domFabSecondary.onclick = async () => {
      state.gameMode = !state.gameMode;
      if (!state.gameMode) {
        cleanUp();
        domFabSecondaryIcon.innerHTML = "gamepad"
        document.getElementById("addCannonbtn").style.display = "block"
        document.getElementById("gravityField").style.display = "block"
      } else {
        domFabSecondaryIcon.innerHTML = "help_outline"
        cleanUp();
        setGameMode();
      }
    }

    function add(cannon) {
      scene.add(cannon)
      cannon.barrel.children.forEach(child => state.objects.push(child));
      cannon.base.children.forEach(child => state.objects.push(child));
      state.cannons.push(cannon)
    }

    function remove(mesh) {
      scene.remove(mesh)
      state.objects.pop(mesh)
    }

    function genModelMenu() {
      modelMenu = gui.addFolder("Selected Cannon options");
      // TODO: add all properties that are going to be editable for the future animation, any constants, etc.
      if (!state.gameMode) {
        let sliderAirResistance = modelMenu.add(state.selectedObject.properties, "air_resistance_coefficient_b").min(0).max(1).step(0.01).setValue(state.selectedObject.properties.air_resistance_coefficient_b).name("Air resistance coefficient").listen();
        let sliderBallMass = modelMenu.add(state.selectedObject.properties, "ball_mass").min(0.1).max(10.0).step(.1).setValue(state.selectedObject.properties.ball_mass).name("Mass of Ball").listen();
      }
      let sliderBallElasticCoeff = modelMenu.add(state.selectedObject.properties, "impact_elastic_coefficient").min(0).max(1.0).step(.02).setValue(state.selectedObject.properties.impact_elastic_coefficient).name("Elastic Coefficient of Impact").listen();
      let sliderRotX = modelMenu.add(state.selectedObject.properties, "rotX").min(0).max(90).step(.5).setValue(state.selectedObject.properties.rotX).name("Cannon angle").listen().onChange(function (value) {
        state.selectedObject.barrel.animateRotXQ((-state.selectedObject.properties.rotX - 90) * Math.PI / 180, 0, .35, 0);
      });
      let sliderInitialSpeed = modelMenu.add(state.selectedObject.properties, "ball_speed").min(1).max(65).step(1).setValue(state.selectedObject.properties.ball_speed).name("Initial Speed").listen();
      modelMenu.open()
      cleanInputsStyle();
    }

    function removeModelMenu() {
      if (modelMenu) {
        gui.removeFolder(modelMenu);
        modelMenu = null;
      }
    }

    function cleanInputsStyle() {
      const guiInputs = gui.domElement.getElementsByTagName("input");
      for (let i = 0; i < guiInputs.length; i++) {
        guiInputs[i].className = "browser-default"
      }
    }


    async function init() {
      // RENDERER
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setScissorTest(true);
      document.body.appendChild(renderer.domElement);

      // CAMERA 0 Perspective
      cameras.push(new THREE.PerspectiveCamera(fovy, aspectRatio, nearPlane, farPlane));
      cameras[0].lookAt(0, 0, 0);
      cameras[0].position.set(10, 2, 0);
      cameraControls = new OrbitControls(cameras[0], renderer.domElement);
      cameraControls.maxPolarAngle = Math.PI / 2 - 0.02

      // CAMERA 1 Top
      cameras.push(new THREE.OrthographicCamera(
        -aspectRatio * map_size / 2, aspectRatio * map_size / 2, map_size / 2, -map_size / 2, -10000, 10000
      ));
      cameras[1].position.set(0, map_size, 0);
      cameras[1].lookAt(0, 0, 0);
      cameras[1].up.set(0, 0, 1);

      // CAMERA 2 Front
      cameras.push(new THREE.OrthographicCamera(
        -aspectRatio * map_size / 4, aspectRatio * map_size / 4, map_size / 2, -map_size / 2, -10000, 10000
      ));
      cameras[2].position.set(0, 1, map_size);
      cameras[2].lookAt(0, 0, 0);
      cameras[2].up.set(0, 1, 0);

      // CAMERA 3 Side
      cameras.push(new THREE.OrthographicCamera(
        -aspectRatio * map_size / 4, aspectRatio * map_size / 4, map_size / 2, -map_size / 2, -10000, 10000
      ));
      cameras[3].position.set(-map_size, 1, 0);
      cameras[3].lookAt(0, 0, 0);
      cameras[3].up.set(0, 1, 0);


      // background
      const path = "textures/bg/";
      const format = '.jpg';
      const urls = [
        path + 'posx' + format, path + 'negx' + format,
        path + 'posy' + format, path + 'negy' + format,
        path + 'posz' + format, path + 'negz' + format
      ];
      const textureCube = new THREE.CubeTextureLoader().load(urls);

      scene = new THREE.Scene();
      scene.background = textureCube;

      const light = new THREE.AmbientLight(0x404040, 5);
      scene.add(light);

      // stats
      stats = new Stats();
      stats.showPanel(0);
      document.body.appendChild(stats.dom);

      // gui
      gui = new dat.GUI();
      gui.add(state, 'references');
      gui.add(state, 'help');
      const gravity = gui.add(state, "gravity").min(0).max(50).step(0.1).setValue(state.gravity).name("Gravity acceleration").listen();
      const addCannonbtn = gui.add(state, 'addCannon');
      addCannonbtn.domElement.parentElement.parentElement.id = "addCannonbtn"
      gravity.domElement.parentElement.parentElement.id = "gravityField"
      cleanInputsStyle();


      // CONTROL TRANSFORM
      transfControl = new TransformControls(cameras[0], renderer.domElement);
      transfControl.rotationSnap = .003
      transfControl.addEventListener('dragging-changed',
        function (event) {
          cameraControls.enabled = !event.value;
        });
      transfControl.setMode("translate");
      transfControl.showX = true
      transfControl.showY = false
      transfControl.showZ = true
      transfControl.addEventListener("mouseDown", e => state.transforming = true)
      transfControl.addEventListener("mouseUp", (e) => {
        state.transforming = false;
        //Updating position / rotation after using transfControl
        state.selectedObject.barrel.position.setFromMatrixPosition(state.selectedObject.barrel.matrix);
        state.selectedObject.barrel.setRotationFromMatrix(state.selectedObject.barrel.matrix);
      });
      scene.add(transfControl);


      // models
      const loader = new THREE.TextureLoader();
      const texture = loader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.magFilter = THREE.NearestFilter;
      const repeats = map_size / 2;
      texture.repeat.set(repeats, repeats);
      const plane = new THREE.PlaneGeometry(map_size, map_size);
      const material = new THREE.MeshPhongMaterial({
        map: texture,
        side: THREE.DoubleSide,
      });
      const floor = new THREE.Mesh(plane, material);
      floor.rotation.x = -0.5 * Math.PI;

      scene.add(floor)
      renderLoop();

      renderer.domElement.addEventListener('pointerdown', e => {
        if (!state.editMode) {
          return;
        }
        mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = - (e.clientY / renderer.domElement.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, cameras[0]);
        const intersects = raycaster.intersectObjects(state.objects);
        if (intersects.length > 0 && state.selectedObject !== intersects[0].object.father && !state.transforming && e.button !== 2) {
          removeModelMenu();
          state.selectedObject = intersects[0].object.father;
          transfControl.attach(state.selectedObject)
          genModelMenu();
        } else if (intersects.length === 0 && !state.transforming) {
          state.selectedObject = null
          transfControl.detach();
          removeModelMenu();
        } else if (intersects.length > 0 && e.button === 2) {
          const selected = intersects[0].object.father;
          transfControl.detach();
          removeModelMenu();
          scene.remove(selected)
          selected.barrel.children.concat(selected.base.children).forEach(child => {
            const i = state.objects.indexOf(child)
            if (i > -1) {
              state.objects.splice(i, 1);
            }
          });
          const i = state.cannons.indexOf(selected);
          if (i > -1) {
            state.cannons.splice(i, 1);
          }
        }
      })
    }

    function renderLoop(time_now) {
      stats.begin();
      drawScene(); // DRAW SCENE
      updateScene(time_now);
      stats.end();
      stats.update();
      requestAnimationFrame(renderLoop);
    }

    function drawScene() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const tempCam = new THREE.PerspectiveCamera(fovy, aspectRatio, nearPlane, 1)


      if (state.editMode) {
        renderer.setViewport(0, 0, w, h);
        renderer.setScissor(0, 0, w, h);
        renderer.render(scene, cameras[0])
      } else {
        renderer.setViewport(w / 2, 0, w / 2, h / 2);
        renderer.setScissor(w / 2, 0, w / 2, h / 2);
        renderer.render(scene, cameras[0])

        // top
        renderer.setViewport(0, h / 2, w / 2, h / 2);
        renderer.setScissor(0, h / 2, w / 2, h / 2);
        tempCam.position.copy(cameras[1].position)
        tempCam.lookAt(0, 0, 0);
        renderer.autoClear = true
        renderer.render(scene, tempCam)
        renderer.autoClear = false
        renderer.render(scene, cameras[1])

        // front z -> origin
        renderer.setViewport(w / 2, h / 2, w / 2, h / 2);
        renderer.setScissor(w / 2, h / 2, w / 2, h / 2);
        tempCam.position.copy(cameras[2].position)
        tempCam.lookAt(0, 0, 0);
        renderer.autoClear = true
        renderer.render(scene, tempCam)
        renderer.autoClear = false
        renderer.render(scene, cameras[2])

        // side x -> origin
        renderer.setViewport(0, 0, w / 2, h / 2);
        renderer.setScissor(0, 0, w / 2, h / 2);
        tempCam.position.copy(cameras[3].position)
        tempCam.lookAt(0, 0, 0);
        renderer.autoClear = true
        renderer.render(scene, tempCam)
        renderer.autoClear = false
        renderer.render(scene, cameras[3])

      }
    }

    function updateScene(time_now) {
      if (!state.editMode) {
        time_now *= 0.001;  // make it seconds
        if (!state.isAnimationStarted) {
          start_time = time_now;
          state.isAnimationStarted = true;
        }

        let time = time_now - start_time;

        state.cannons.forEach(async (c, i) => {
          let s0, v0, m, exp, g, b, bm, mb, exp_bounce, delta_t;
          b = c.properties.air_resistance_coefficient_b;
          g = -1 * state.gravity;
          v0 = c.ball.properties.initial_velocity;
          s0 = c.ball.properties.initial_position;
          m = c.ball.properties.mass;
          delta_t = (time - c.ball.properties.last_time_bounce);

          if (c.ball.position.x > map_size / 2 || c.ball.position.x < -map_size / 2
            || c.ball.position.z > map_size / 2 || c.ball.position.z < -map_size / 2
            || c.ball.position.y > map_size / 2
            //|| c.ball.position.y < 0
          ) {
            return
          }
          if (b > 0.001) {
            // calculations with air resistance.
            bm = b / m;
            mb = m / b;
            exp = Math.exp(-bm * time);
            exp_bounce = Math.exp(bm * c.ball.properties.last_time_bounce);

            c.ball.properties.acceleration.x = -bm * v0.x * exp;
            c.ball.properties.acceleration.y = (-(bm * v0.y) + g) * exp * exp_bounce;
            c.ball.properties.acceleration.z = -bm * v0.z * exp;

            c.ball.properties.velocity.x = v0.x * exp;
            c.ball.properties.velocity.y = (v0.y * exp * exp_bounce) + ((1 - (exp * exp_bounce)) * (mb * g));
            c.ball.properties.velocity.z = v0.z * exp;

            c.ball.properties.displacement.x = (mb * v0.x * (1 - exp));
            c.ball.properties.displacement.y = (mb * (v0.y - mb * g) * (1 - (exp * exp_bounce))) + (mb * g * delta_t);
            c.ball.properties.displacement.z = (mb * v0.z * (1 - exp));
          } else {
            // air resistance deprecated
            c.ball.properties.acceleration.x = 0;
            c.ball.properties.acceleration.y = g;
            c.ball.properties.acceleration.z = 0;

            c.ball.properties.velocity.x = v0.x;
            c.ball.properties.velocity.y = v0.y + (delta_t * g);
            c.ball.properties.velocity.z = v0.z;

            c.ball.properties.displacement.x = (time * v0.x);
            c.ball.properties.displacement.y = (delta_t * v0.y) + (0.5 * g * delta_t * delta_t);
            c.ball.properties.displacement.z = (time * v0.z);
          }

          c.ball.position.set(
            s0.x + c.ball.properties.displacement.x,
            (s0.y + c.ball.properties.displacement.y) > c.ball.properties.radius ? (s0.y + c.ball.properties.displacement.y) : c.ball.properties.radius,
            s0.z + c.ball.properties.displacement.z,
          );

          if (curr_point < MAX_POINTS) {
            const line = state.lines[i];
            const data = line.geometry.attributes.position.array;
            data[curr_point] = c.ball.position.x
            data[curr_point + 1] = c.ball.position.y
            data[curr_point + 2] = c.ball.position.z
            line.geometry.setDrawRange(0, curr_point / 3 + 1);
            line.geometry.attributes.position.needsUpdate = true;
          }

          if (state.gameMode) {
            console.log("here")

            if (c.ball.position.x < state.target.position.x + 2
              && c.ball.position.x > state.target.position.x - 2
              && c.ball.position.y < (state.target.position.y + 2.45) + 3
              && c.ball.position.y > (state.target.position.y + 2.45) - 3
              && c.ball.position.z < state.target.position.z + 2
              && c.ball.position.z > state.target.position.z - 2) {
              alert(`You hit it!\nIt took you ${state.totalTries} attempts`)
              cleanUp()
              domFabMain.onclick();
              await setGameMode()
              return;
            }
          }

          //bouncing
          if (c.ball.properties.bounce_status === bounce_states.HAS_NOT_BOUNCED && c.ball.position.y < c.ball.properties.radius) {
            console.log(c.ball.properties.bounce_status, c.ball.position.y, c.ball.properties.radius)
            c.ball.properties.bounce_status = bounce_states.HAS_BOUNCED;
            c.ball.properties.last_time_bounce = time;
            c.ball.properties.initial_velocity.y = -1 * c.properties.impact_elastic_coefficient * c.ball.properties.velocity.y;
            c.ball.properties.initial_position.y = c.ball.position.y;
          } else if (c.ball.properties.bounce_status === bounce_states.HAS_BOUNCED && c.ball.position.y < c.ball.properties.radius) {
            c.ball.properties.bounce_status = bounce_states.START;
          } else if (c.ball.properties.bounce_status === bounce_states.START && c.ball.properties.velocity.y < 0) {
            c.ball.properties.bounce_status = bounce_states.HAS_NOT_BOUNCED;
          }

        });
        curr_point += 3;

        // if in gamemode, then calculate if it colides with target, if not after the objet is below y=0 or outside some bounding box, tries+=1 and change mode to editMode
      } else {
        if (state.isAnimationStarted) {
          state.isAnimationStarted = false;
        }
      }
    }

    window.addEventListener("resize", () => {
      const aspect = window.innerWidth / window.innerHeight;
      cameras.forEach(c => {
        c.aspect = aspect;
        c.updateProjectionMatrix()
      })
      cameraControls.update();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }, false);

    document.addEventListener("DOMContentLoaded", init);

    document.addEventListener('keypress', e => {
      switch (e.code) {
        case "KeyR":
          transfControl.showX = false
          transfControl.showY = true
          transfControl.showZ = false
          transfControl.setMode("rotate")
          break;
        case "KeyT":
          if (state.gameMode) {
            return;
          }
          transfControl.showX = true
          transfControl.showY = false
          transfControl.showZ = true
          transfControl.setMode("translate")
          break;
        case "KeyC":
          if (state.selectedObject) {
            let sel = state.selectedObject;
            let cannon = new Cannon()
            cannon.properties.air_resistance_coefficient_b = sel.properties.air_resistance_coefficient_b;
            cannon.properties.ball_mass = sel.properties.ball_mass
            cannon.properties.ball_speed = sel.properties.ball_speed
            cannon.properties.impact_elastic_coefficient = sel.properties.impact_elastic_coefficient
            cannon.properties.rotX = sel.properties.rotX
            cannon.barrel.animateRotXQ((-state.selectedObject.properties.rotX - 90) * Math.PI / 180, 0, .35, 0);
            cannon.position.x = sel.position.x
            cannon.position.y = sel.position.y
            cannon.position.z = sel.position.z
            add(cannon);
          }
          break;
      }
    })
  </script>


  <script>
    // ALL MATERIALIZE RELATED STUFF
    document.addEventListener('DOMContentLoaded', function () {
      var elems = document.querySelectorAll('.fixed-action-btn');
      var instances = M.FloatingActionButton.init(elems, {});
    });

    document.addEventListener('DOMContentLoaded', function () {
      var elems = document.querySelectorAll('.modal');
      var instances = M.Modal.init(elems);
    });

  </script>
</body>

</html>