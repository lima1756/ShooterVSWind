<!DOCTYPE html>
<html lang="en">

<head>
  <title>Project</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  <!-- Compiled and minified CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">

  <!-- Compiled and minified JavaScript -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>


<body>


  <div class="fixed-action-btn">
    <a class="btn-floating btn-large red" id="fab_main">
      <i class="large material-icons" id="fab_main_icon">play_arrow</i>
    </a>
    <ul>
      <li><a class="btn-floating red" id="fab_secondary"><i class="material-icons"
            id="fab_secondary_icon">gamepad</i></a>
      </li>
    </ul>
  </div>


  <script type="module">
    "using strict";
    import * as THREE from "https://unpkg.com/three@0.127.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.127.0/examples/jsm/controls/OrbitControls.js";
    import { TransformControls } from "https://unpkg.com/three@0.127.0/examples/jsm/controls/TransformControls.js";
    import Stats from "https://unpkg.com/three@0.127.0/examples/jsm/libs/stats.module.js";
    import dat from "https://unpkg.com/three@0.127.0/examples/jsm/libs/dat.gui.module.js";

    class Composite extends THREE.Group {
      constructor() {
        super();
        this.matrixModel = new THREE.Matrix4();
      }

      addWiframeHelper(color = new THREE.Color(0, 0, 0)) {
        this.wireframeHelper = new THREE.LineSegments(new THREE.WireframeGeometry(this.geometry));
        this.wireframeHelper.material.color = color;
        this.add(this.wireframeHelper);
      }

      addLocalAxes(visible = false) {
        this.geometry.computeBoundingSphere();
        this.axes = new THREE.AxesHelper(this.geometry.boundingSphere.radius * 1.5);
        this.axes.visible = visible;
        this.add(this.axes);
      }

      getCentroid() {
        this.geometry.computeBoundingSphere();
        return this.geometry.boundingSphere.center;
      }

      getScale(sx, sy, sz) {
        let S = new THREE.Matrix4();
        S.makeScale(sx, sy, sz);
        return S;
      }

      getRotationX(theta) {
        let R = new THREE.Matrix4();
        R.makeRotationX(theta);
        return R;
      }

      getRotationY(theta) {
        let R = new THREE.Matrix4();
        R.makeRotationY(theta);
        return R;
      }

      getRotationZ(theta) {
        let R = new THREE.Matrix4();
        R.makeRotationZ(theta);
        return R;
      }

      getRotationXQ(theta, xq, yq, zq) {
        // M = T2(xq,yq,zq) Rx T1(-xq,-yq,-zq)
        let T2 = this.getTranslation(xq, yq, zq);
        let Rx = this.getRotationX(theta);
        let T1 = this.getTranslation(-xq, -yq, -zq);
        let M = new THREE.Matrix4();
        M.multiplyMatrices(T2, Rx);
        M.multiplyMatrices(M, T1);
        return M;
      }

      getRotationYQ(theta, xq, yq, zq) {
        // M = T2(xq,yq,zq) Ry T1(-xq,-yq,-zq)
        let T2 = this.getTranslation(xq, yq, zq);
        let Ry = this.getRotationY(theta);
        let T1 = this.getTranslation(-xq, -yq, -zq);
        let M = new THREE.Matrix4();
        M.multiplyMatrices(T2, Ry);
        M.multiplyMatrices(M, T1);
        return M;
      }

      getRotationZQ(theta, xq, yq, zq) {
        // M = T2(xq,yq,zq) Rz T1(-xq,-yq,-zq)
        let T2 = this.getTranslation(xq, yq, zq);
        let Rz = this.getRotationZ(theta);
        let T1 = this.getTranslation(-xq, -yq, -zq);
        let M = new THREE.Matrix4();
        M.multiplyMatrices(T2, Rz);
        M.multiplyMatrices(M, T1);
        return M;
      }

      getTranslation(tx, ty, tz) {
        let T = new THREE.Matrix4();
        T.makeTranslation(tx, ty, tz);
        return T;
      }

      addScale(sx, sy, sz) {
        let S = new THREE.Matrix4();
        S.makeScale(sx, sy, sz);
        this.matrixModel.multiply(S);
        this.setMatrix();
      }

      addRotationX(theta) {
        let R = new THREE.Matrix4();
        R.makeRotationX(theta);
        this.matrixModel.multiply(R);
        this.setMatrix();
      }

      addRotationY(theta) {
        let R = new THREE.Matrix4();
        R.makeRotationY(theta);
        this.matrixModel.multiply(R);
        this.setMatrix();
      }

      addRotationZ(theta) {
        let R = new THREE.Matrix4();
        R.makeRotationZ(theta);
        this.matrixModel.multiply(R);
        this.setMatrix();
      }

      addRotationXQ(theta, xq, yq, zq) {
        this.addTranslation(xq, yq, zq);
        this.addRotationX(theta);
        this.addTranslation(-xq, -yq, -zq);
        this.setMatrix();
      }

      addRotationYQ(theta, xq, yq, zq) {
        this.addTranslation(xq, yq, zq);
        this.addRotationY(theta);
        this.addTranslation(-xq, -yq, -zq);
        this.setMatrix();
      }

      addRotationZQ(theta, xq, yq, zq) {
        this.addTranslation(xq, yq, zq);
        this.addRotationZ(theta);
        this.addTranslation(-xq, -yq, -zq);
        this.setMatrix();
      }

      addTranslation(tx, ty, tz) {
        let T = new THREE.Matrix4();
        T.makeTranslation(tx, ty, tz);
        this.matrixModel.multiply(T);
        this.setMatrix();
      }

      animateRotX(theta) {
        let RX = this.getRotationX(theta);
        let M = new THREE.Matrix4();
        M.multiplyMatrices(RX, this.matrixModel);
        this.setMatrix(M);
      }

      animateRotY(theta) {
        let RY = this.getRotationY(theta);
        let M = new THREE.Matrix4();
        M.multiplyMatrices(RY, this.matrixModel);
        this.setMatrix(M);
      }

      animateRotZ(theta) {
        let RZ = this.getRotationZ(theta);
        let M = new THREE.Matrix4();
        M.multiplyMatrices(RZ, this.matrixModel);
        this.setMatrix(M);
      }

      animateRotXQ(theta, xq, yq, zq) {
        let RXQ = this.getRotationXQ(theta, xq, yq, zq);
        let M = new THREE.Matrix4();
        M.multiplyMatrices(RXQ, this.matrixModel);
        this.setMatrix(M);
      }

      animateRotYQ(theta, xq, yq, zq) {
        // M = T(Q) Ry T(-Q)
        let RYQ = this.getRotationYQ(theta, xq, yq, zq);
        let M = new THREE.Matrix4();
        M.multiplyMatrices(RYQ, this.matrixModel);
        this.setMatrix(M);
      }

      animateRotZQ(theta, xq, yq, zq) {
        let RZQ = this.getRotationZQ(theta, xq, yq, zq);
        let M = new THREE.Matrix4();
        M.multiplyMatrices(RZQ, this.matrixModel);
        this.setMatrix(M);
      }

      setMatrix(matrix = this.matrixModel) {
        this.matrixAutoUpdate = false;
        this.matrix.copy(matrix);
      }

      setMatrixIdentity() {
        this.matrixAutoUpdate = false;
        this.matrix.copy(new THREE.Matrix4());
      }

      // Set matrix with matrixModel
      resetMatrix() {
        this.matrixAutoUpdate = false;
        this.matrix.copy(this.matrixModel);
      }

    }

    class CannonBarrelFront extends THREE.Mesh {
      constructor(father) {
        super();
        this.father = father;
        this.geometry = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 64,
                1, true);
        const loader = new THREE.TextureLoader();
        this.material = new THREE.MeshBasicMaterial({
          map: loader.load('./textures/metal.jpg'),side: THREE.DoubleSide
        });
        //this.material = new THREE.MeshBasicMaterial({color: "#485555", side: THREE.DoubleSide});
        //this.addWiframeHelper(new THREE.Color(0, 0, 0));

      }
    }

    class CannonBarrelBack extends THREE.Mesh {
      constructor(father) {
        super();
        this.father = father;
        this.geometry = new THREE.SphereGeometry(0.43, 32, 32);
        const loader = new THREE.TextureLoader();
        this.material = new THREE.MeshBasicMaterial({
          map: loader.load('./textures/metal.jpg'),side: THREE.DoubleSide
        });
        //this.material = new THREE.MeshBasicMaterial({color: "#485555", side: THREE.DoubleSide});
        //this.addWiframeHelper(new THREE.Color(0, 0, 0));

      }
    }

    class CannonBarrelRing extends THREE.Mesh {
      constructor(father) {
        super();
        this.father = father;
        this.geometry = new THREE.TorusGeometry(0.4, 0.08, 30, 100);
        const loader = new THREE.TextureLoader();
        this.material = new THREE.MeshBasicMaterial({
          map: loader.load('./textures/metalDetails.jpg'),side: THREE.DoubleSide
        });
        //this.material = new THREE.MeshBasicMaterial({color: "#646868", side: THREE.DoubleSide});
        //this.addWiframeHelper(new THREE.Color(0, 0, 0));
        this.rotation.x = -Math.PI / 2;

      }
    }

    class CannonBarrel extends Composite {
      constructor(father) {
        super();
        this.children = [];
        this.father = father;
        this.barrelFront = new CannonBarrelFront(father);
        this.barrelFrontInner = new CannonBarrelFront(father);
        this.barrelFrontInner.scale.set(.8, 1, .8);
        this.barrelBack = new CannonBarrelBack(father);
        this.barrelBack.position.set(0, 0.75, 0);
        this.barrelBack2 = new CannonBarrelBack(father);
        this.barrelBack2.position.set(0, 1.15, 0);
        this.barrelBack2.scale.set(.3, .3, .3);
        this.barrelRing = new CannonBarrelRing(father);
        this.barrelRing.position.set(0, -0.75, 0);
        this.barrelRing1 = new CannonBarrelRing(father);
        this.barrelRing1.position.set(0, 0.06, 0);
        this.barrelRing1.scale.set(.9, .9, .5);
        this.barrelRing2 = new CannonBarrelRing(father);
        this.barrelRing2.position.set(0, -0.06, 0);
        this.barrelRing2.scale.set(.9, .9, .5);
        this.barrelRing3 = new CannonBarrelRing(father);
        this.barrelRing3.position.set(0, .60, 0);
        this.barrelRing3.scale.set(.9, .9, .5);

        this.add(this.barrelFront);
        this.add(this.barrelFrontInner);
        this.add(this.barrelBack);
        this.add(this.barrelBack2);
        this.add(this.barrelRing);
        this.add(this.barrelRing1);
        this.add(this.barrelRing2);
        this.add(this.barrelRing3);

        this.children.push(this.barrelFront);
        this.children.push(this.barrelFrontInner);
        this.children.push(this.barrelBack);
        this.children.push(this.barrelBack2);
        this.children.push(this.barrelRing);
        this.children.push(this.barrelRing1);
        this.children.push(this.barrelRing2);
        this.children.push(this.barrelRing3);
        this.position.set(0, 0.35, .4);
      }
    }

    class CannonBaseBox extends THREE.Mesh {
      constructor(father) {
        super();
        this.father = father;
        this.geometry = new THREE.BoxGeometry(1, 1, 1);
        const loader = new THREE.TextureLoader();
        this.material = new THREE.MeshBasicMaterial({
          map: loader.load('./textures/woodPlank.jpg'),
        });
        //this.material = new THREE.MeshBasicMaterial({color: "#664230", side: THREE.DoubleSide});
        //this.addWiframeHelper(new THREE.Color(0, 0, 0));
        this.rotation.x = -Math.PI / 2;

      }

    }

    class CannonBaseWheel extends THREE.Mesh {
      constructor(father) {
        super();
        this.father = father;
        this.geometry = new THREE.CylinderGeometry(0.5, 0.5, .1, 64,
                1, false);
        const loader = new THREE.TextureLoader();
        this.material = new THREE.MeshBasicMaterial({
          map: loader.load('./textures/rock.jpg'),side: THREE.DoubleSide
        });
        //this.material = new THREE.MeshBasicMaterial({color: "#485555", side: THREE.DoubleSide});
        //this.addWiframeHelper(new THREE.Color(0, 0, 0));
        this.rotation.z = -Math.PI / 2;

      }
    }

    class CannonBaseBolt extends THREE.Mesh {
      constructor(father) {
        super();
        this.father = father;
        this.geometry = new THREE.CylinderGeometry(0.5, 0.5, .1, 64,
                1, false);
        const loader = new THREE.TextureLoader();
        this.material = new THREE.MeshBasicMaterial({
          map: loader.load('./textures/metalDetails.jpg'),side: THREE.DoubleSide
        });
        //this.material = new THREE.MeshBasicMaterial({color: "#363939", side: THREE.DoubleSide});
        //this.addWiframeHelper(new THREE.Color(0, 0, 0));
        this.rotation.z = -Math.PI / 2;

      }
    }

    class CannonBase extends Composite {
      constructor(father) {
        super();
        this.children = [];
        this.father = father;
        this.frontBox = new CannonBaseBox(father);
        this.frontBox.scale.set(1.6, .5, .7);
        this.frontBox.position.set(0, -.5, .7);
        this.add(this.frontBox);
        this.children.push(this.frontBox);

        this.floorBox = new CannonBaseBox(father);
        this.floorBox.scale.set(1.6, 2, .19);
        this.floorBox.position.set(0, -.95, -.05);
        this.add(this.floorBox);
        this.children.push(this.floorBox);

        this.rightUpBox = new CannonBaseBox(father);
        this.rightUpBox.scale.set(.09, 1, .23);
        this.rightUpBox.position.set(.75, -.26, 0.3);
        this.add(this.rightUpBox);
        this.children.push(this.rightUpBox);
        this.rightMiddleBox = new CannonBaseBox(father);
        this.rightMiddleBox.scale.set(.09, 1.5, .23);
        this.rightMiddleBox.position.set(.75, -.52, 0.15);
        this.add(this.rightMiddleBox);
        this.children.push(this.rightMiddleBox);
        this.rightDownBox = new CannonBaseBox(father);
        this.rightDownBox.scale.set(.09, 1.7, .23);
        this.rightDownBox.position.set(.75, -.78, -.08);
        this.add(this.rightDownBox);
        this.children.push(this.rightDownBox);

        this.leftUpBox = new CannonBaseBox(father);
        this.leftUpBox.scale.set(.09, 1, .23);
        this.leftUpBox.position.set(-.75, -.26, 0.3);
        this.add(this.leftUpBox);
        this.children.push(this.leftUpBox);
        this.leftMiddleBox = new CannonBaseBox(father);
        this.leftMiddleBox.scale.set(.09, 1.5, .23);
        this.leftMiddleBox.position.set(-.75, -.52, 0.15);
        this.add(this.leftMiddleBox);
        this.children.push(this.leftMiddleBox);
        this.leftDownBox = new CannonBaseBox(father);
        this.leftDownBox.scale.set(.09, 1.7, .23);
        this.leftDownBox.position.set(-.75, -.78, -.08);
        this.add(this.leftDownBox);
        this.children.push(this.leftDownBox);

        this.frontRightWheel = new CannonBaseWheel(father);
        this.frontRightWheel.position.set(.9, -.79, .7);
        this.add(this.frontRightWheel);
        this.children.push(this.frontRightWheel);
        this.frontRightBolt = new CannonBaseBolt(father);
        this.frontRightBolt.scale.set(.1, 2, .1);
        this.frontRightBolt.position.set(.9, -.79, .7);
        this.add(this.frontRightBolt);
        this.children.push(this.frontRightBolt);

        this.frontLeftWheel = new CannonBaseWheel(father);
        this.frontLeftWheel.position.set(-.9, -.79, .7);
        this.add(this.frontLeftWheel);
        this.children.push(this.frontLeftWheel);
        this.frontLeftBolt = new CannonBaseBolt(father);
        this.frontLeftBolt.scale.set(.1, 2, .1);
        this.frontLeftBolt.position.set(-.9, -.79, .7);
        this.add(this.frontLeftBolt);
        this.children.push(this.frontLeftBolt);

        this.backRightWheel = new CannonBaseWheel(father);
        this.backRightWheel.scale.set(.7, 1, .7);
        this.backRightWheel.position.set(.9, -.95, -.7);
        this.add(this.backRightWheel);
        this.children.push(this.backRightWheel);
        this.backRightBolt = new CannonBaseBolt(father);
        this.backRightBolt.scale.set(.1, 2, .1);
        this.backRightBolt.position.set(.9, -.95, -.7);
        this.add(this.backRightBolt);
        this.children.push(this.backRightBolt);

        this.backLeftWheel = new CannonBaseWheel(father);
        this.backLeftWheel.scale.set(.7, 1, .7);
        this.backLeftWheel.position.set(-.9, -.95, -.7);
        this.add(this.backLeftWheel);
        this.children.push(this.backLeftWheel);
        this.backLeftBolt = new CannonBaseBolt(father);
        this.backLeftBolt.scale.set(.1, 2, .1);
        this.backLeftBolt.position.set(-.9, -.95, -.7);
        this.add(this.backLeftBolt);
        this.children.push(this.backLeftBolt);



      }
    }

    class Cannon extends THREE.Group {

      properties = { rotX : 0, dummy : 8}

      constructor() {
        super();

        this.barrel = new CannonBarrel(this);
        this.barrel.rotation.x = -Math.PI / 2;
        this.base = new CannonBase(this);
        this.add(this.base);
        this.add(this.barrel);
        this.position.set(0, 1.3, 0);
      }
    }

    class Cannon2 extends THREE.Mesh {
      // TODO: add all properties that are going to be editable for the future animation, like resistance, any constants, etc.
      properties = { dummy: 8, rotX : 0 }

      constructor(x = 0, z = 0) {
        super();
        this.geometry = new THREE.BoxGeometry(1, 1, 1);
        this.material = new THREE.MeshBasicMaterial({ color: 111 });
        this.position.set(x, 0.5, z)
      }
    }


    class Target extends THREE.Mesh {
      constructor(x, y, z) {
        super();
        this.geometry = new THREE.PlaneGeometry(2, 2, 1);
        this.material = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
        this.position.set(x, y, z)
        this.lookAt(0, 0, 0)
      }
    }

    // THREEjs variables
    let scene, renderer, stats, cameraControls, transfControl, gui, modelMenu;
    let cameras = []; // perspective, top, fron, side
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const state = {
      references: () => alert(`texture Yokohama 3 by Humus (http://www.humus.name/index.php?page=Textures)`),
      help: () => alert(`Click on cannons to move or rotate, R key to set rotation mode, T key to set translation mode`),
      addCannon: () => {
        add(new Cannon())
      },
      objects: [],
      editMode: true,
      gameMode: false,
      selectedObject: null,
      totalTries: 0,
      transforming: false,
    };


    const domFabMain = document.getElementById("fab_main")
    const domFabSecondary = document.getElementById("fab_secondary")
    const domFabMainIcon = document.getElementById("fab_main_icon")
    const domFabSecondaryIcon = document.getElementById("fab_secondary_icon")

    domFabMain.onclick = () => {
      state.editMode = !state.editMode
      if (!state.editMode) {
        domFabMainIcon.innerHTML = "stop"
        transfControl.detach();
        removeModelMenu();
        gui.close();
        console.log(document.getElementById("addCannonbtn"))
        document.getElementById("addCannonbtn").style.display = "none"
        // TODO if some variable needs to be initializated for the simulation
      }
      else {
        // TODO if something needs to be stopped/removed/cleaned
        gui.open();
        document.getElementById("addCannonbtn").style.display = "block"
        domFabMainIcon.innerHTML = "play_arrow"
      }
    }

    domFabSecondary.onclick = () => {
      state.gameMode = !state.gameMode;
      if (!state.gameMode) {
        // TODO: complete cleanup (?)
        domFabSecondaryIcon.innerHTML = "gamepad"
        document.getElementById("addCannonbtn").style.display = "block"
      } else {
        domFabSecondaryIcon.innerHTML = "help_outline"
        document.getElementById("addCannonbtn").style.display = "none"
        // TODO: add target randomly and set all variables to play
        // I'm thinking on automatically add the cannon in the origin and disable movement, 
        // just enable rotation so the player needs to target without moving it
        state.totalTries = 0
      }
    }

    function add(cannon) {
      scene.add(cannon)
      cannon.barrel.children.forEach(child => state.objects.push(child));
      cannon.base.children.forEach(child => state.objects.push(child));
      //state.objects.push(cannon)
    }

    function remove(mesh) {
      scene.remove(mesh)
      state.objects.pop(mesh)
    }

    function genModelMenu() {
      modelMenu = gui.addFolder("Selected Cannon options")
      // TODO: add all properties that are going to be editable for the future animation, like resistance, any constants, etc.
      let dummyProperty = modelMenu.add(state.selectedObject.properties, "dummy").min(-10).max(10).name("Dummy");
      let sliderRotX = modelMenu.add(state.selectedObject.properties, "rotX").min(-180).max(-90).step(10).setValue(-90).name("X (deg)").listen().onChange(function (value) {
        state.selectedObject.barrel.animateRotXQ(state.selectedObject.properties.rotX * Math.PI / 180, 0, .35, 0);
      });
      modelMenu.open()
      cleanInputsStyle();
    }

    function removeModelMenu() {
      if (modelMenu) {
        gui.removeFolder(modelMenu);
        modelMenu = null;
      }
    }

    function cleanInputsStyle() {
      const guiInputs = gui.domElement.getElementsByTagName("input");
      for (let i = 0; i < guiInputs.length; i++) {
        guiInputs[i].className = "browser-default"
      }
    }


    function init() {
      // RENDERER
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setScissorTest(true);
      document.body.appendChild(renderer.domElement);

      // Camera configuration
      let fovy = 60.0;    // Field ov view
      let aspectRatio = window.innerWidth / window.innerHeight;
      let nearPlane = 0.1;
      let farPlane = 10000.0;

      // CAMERA 0 Perspective
      cameras.push(new THREE.PerspectiveCamera(fovy, aspectRatio, nearPlane, farPlane));
      cameras[0].lookAt(0, 0, 0);
      cameras[0].position.set(10, 2, 0);
      cameraControls = new OrbitControls(cameras[0], renderer.domElement);
      cameraControls.maxPolarAngle = Math.PI / 2 - 0.02

      // CAMERA 1 Top
      cameras.push(new THREE.PerspectiveCamera(fovy, aspectRatio, nearPlane, farPlane));
      cameras[1].position.set(0, 30, 0);
      cameras[1].lookAt(0, 0, 0);
      cameras[1].up.set(0, 0, 1);

      // CAMERA 2 Front
      cameras.push(new THREE.PerspectiveCamera(fovy, aspectRatio, nearPlane, farPlane));
      cameras[2].position.set(0, 1, 30);
      cameras[2].lookAt(0, 0, 0);
      cameras[2].up.set(0, 1, 0);

      // CAMERA 3 Side
      cameras.push(new THREE.PerspectiveCamera(fovy, aspectRatio, nearPlane, farPlane));
      cameras[3].position.set(-30, 1, 0);
      cameras[3].lookAt(0, 0, 0);
      cameras[3].up.set(0, 1, 0);


      // background
      const path = "textures/bg/";
      const format = '.jpg';
      const urls = [
        path + 'posx' + format, path + 'negx' + format,
        path + 'posy' + format, path + 'negy' + format,
        path + 'posz' + format, path + 'negz' + format
      ];
      const textureCube = new THREE.CubeTextureLoader().load(urls);

      scene = new THREE.Scene();
      scene.background = textureCube;

      // stats
      stats = new Stats();
      stats.showPanel(0);
      document.body.appendChild(stats.dom);

      // gui
      gui = new dat.GUI();
      gui.add(state, 'references');
      gui.add(state, 'help');
      const addCannonbtn = gui.add(state, 'addCannon')
      addCannonbtn.domElement.parentElement.parentElement.id = "addCannonbtn"

      //let sliderRotX = gui.add(state.selectedObject.properties, "dummy").min(-10).max(10).name("Dummy");



      cleanInputsStyle();


      // CONTROL TRANSFORM
      transfControl = new TransformControls(cameras[0], renderer.domElement);
      transfControl.addEventListener('dragging-changed',
        function (event) {
          cameraControls.enabled = !event.value;
        });
      transfControl.setMode("translate");
      transfControl.showX = true
      transfControl.showY = false
      transfControl.showZ = true
      transfControl.addEventListener("mouseDown", e => state.transforming = true)
      transfControl.addEventListener("mouseUp", e => state.transforming = false)
      scene.add(transfControl);


      // models
      const plane = new THREE.PlaneGeometry(64, 64);
      const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const floor = new THREE.Mesh(plane, material);
      floor.rotation.x = -0.5 * Math.PI;

      scene.add(floor)
      scene.add(new Target(2, 2, 0))
      //add(new Cannon2())
      let cannon = new Cannon();
      add(cannon);// this adds the object to the modifiable list
      renderLoop();

      renderer.domElement.addEventListener('pointerdown', e => {
        if (!state.editMode) {
          return;
        }
        mouse.x = (e.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = - (e.clientY / renderer.domElement.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, cameras[0]);
        const intersects = raycaster.intersectObjects(state.objects);
        if (intersects.length > 0 && state.selectedObject !== intersects[0].object.father && !state.transforming) {
          removeModelMenu();
          state.selectedObject = intersects[0].object.father
          transfControl.attach(state.selectedObject)
          genModelMenu();
        } else if (intersects.length === 0 && !state.transforming) {
          state.selectedObject = null
          transfControl.detach();
          removeModelMenu();
        }
      })
    }

    function renderLoop() {
      stats.begin();
      drawScene(); // DRAW SCENE
      updateScene();
      stats.end();
      stats.update();
      requestAnimationFrame(renderLoop);
    }

    function drawScene() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      if (state.editMode) {
        renderer.setViewport(0, 0, w, h);
        renderer.setScissor(0, 0, w, h);
        renderer.render(scene, cameras[0])
      } else {
        renderer.setViewport(w / 2, 0, w / 2, h / 2);
        renderer.setScissor(w / 2, 0, w / 2, h / 2);
        renderer.render(scene, cameras[0])

        // top
        renderer.setViewport(0, h / 2, w / 2, h / 2);
        renderer.setScissor(0, h / 2, w / 2, h / 2);
        renderer.render(scene, cameras[1])

        // front z -> origin
        renderer.setViewport(w / 2, h / 2, w / 2, h / 2);
        renderer.setScissor(w / 2, h / 2, w / 2, h / 2);
        renderer.render(scene, cameras[2])

        // side x -> origin
        renderer.setViewport(0, 0, w / 2, h / 2);
        renderer.setScissor(0, 0, w / 2, h / 2);
        renderer.render(scene, cameras[3])

      }
    }

    function updateScene() {
      if (!state.editMode) {
        // TODO: animate cannons and other stuff if required
        // if in gamemode, then calculate if it colides with target, if not after the objet is below y=0 or outside some bounding box, tries+=1 and change mode to editMode
      }
    }

    window.addEventListener("resize", () => {
      const aspect = window.innerWidth / window.innerHeight;
      cameras.forEach(c => {
        c.aspect = aspect;
        c.updateProjectionMatrix()
      })
      cameraControls.update();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }, false);

    document.addEventListener("DOMContentLoaded", init);

    document.addEventListener('keypress', e => {
      switch (e.code) {
        case "KeyR":
          transfControl.showX = false
          transfControl.showY = true
          transfControl.showZ = false
          transfControl.setMode("rotate")
          break;
        case "KeyT":
          transfControl.showX = true
          transfControl.showY = false
          transfControl.showZ = true
          transfControl.setMode("translate")
          break;
      }
    })
  </script>


  <script>
    // ALL MATERIALIZE RELATED STUFF
    document.addEventListener('DOMContentLoaded', function () {
      var elems = document.querySelectorAll('.fixed-action-btn');
      var instances = M.FloatingActionButton.init(elems, {});
    });
  </script>
</body>

</html>